# VELKYMI PISMENY jsou znaceny NETERMINALY
# malymi pismeny jsou znaceny terminaly (mely by byt identicke s tokeny)
# startovnim NETERMINALEM je START
# znakem mrizka zacinaji komentare
# pokud není jinak uvedeno tak identifier náleží {identifier proměnné / konstanty}
# nasledujici znaky byly pro citelnosti napsany primo narozdil od jejich token-formy
# . dot
# : colon
# ( bracket_left_simple
# ) bracket_rigth_simple
# { bracket_left_curly
# } bracket_right_curly
# , comma
# | pipe
# = assign
#
# Jak modelovat vestavene funkce? pridat sem, nebo ne?


START -> PROLOG FUNC_DEF_NEXT END

END -> eof_token

PROLOG -> const ifj = import ( string ) ;

FUNC_DEF_NEXT -> FUNC_DEF epsilon
FUNC_DEF_NEXT -> FUNC_DEF FUNC_DEF_NEXT

FUNC_DEF -> pub fn identifier ( PARAMS ) TYPE { CODE_BLOCK_NEXT }
#                       |- identifier funkce
FUNC_DEF -> pub fn identifier ( PARAMS ) void { CODE_BLOCK_NEXT }
#                       |- identifier funkce

PARAM -> identifier : TYPE

PARAMS -> epsilon
PARAMS -> PARAM PARAM_NEXT

PARAM_NEXT -> epsilon
PARAM_NEXT -> PARAM_COMMA epsilon
PARAM_NEXT -> PARAM_COMMA PARAM PARAM_NEXT

PARAM_COMMA -> ,

TYPE -> type_int
TYPE -> type_float
TYPE -> type_string
TYPE -> type_int_null
TYPE -> type_float_null
TYPE -> type_string_null

CODE_BLOCK_NEXT -> epsilon
CODE_BLOCK_NEXT -> CODE_BLOCK CODE_BLOCK_NEXT

CODE_BLOCK -> VAR_DEF
CODE_BLOCK -> ASSIGN
CODE_BLOCK -> IF_STATEMENT
CODE_BLOCK -> WHILE_STATEMENT
CODE_BLOCK -> VOID_FUNCTION_CALL
CODE_BLOCK -> RETURN

VAR_DEF -> const identifier : TYPE = EXPRESSION ;
VAR_DEF -> var identifier : TYPE = EXPRESSION ;

ASSIGN -> identifier = EXPRESSION ;
ASSIGN -> identifier = identifier ( ARGUMENTS ) ;
#                            |- tento identifier náleží {funkce}
ASSIGN -> identifier = ifj . identifier ( ARGUMENTS ) ;
#                                |- tento identifier náleží {vestavěné funkce}
ASSIGN -> identifier_discard = identifier ( ARGUMENTS ) ;
#                                   |- tento identifier náleží {funkce}
ASSIGN -> identifier_discard = ifj . identifier ( ARGUMENTS )
#                                       |- tento identifier náleží {vestavěné funkce}

ARGUMENTS -> epsilon
ARGUMENTS -> ARGUMENT ARGUMENT_NEXT

ARGUMENT_NEXT -> epsilon
ARGUMENT_NEXT -> ARGUMENT_COMMA epsilon
ARGUMENT_NEXT -> ARGUMENT_COMMA ARGUMENT ARGUMENT_NEXT

ARGUMENT_COMMA -> ,

ARGUMENT -> identifier
ARGUMENT -> int
ARGUMENT -> float
ARGUMENT -> string

IF_STATEMENT -> if ( BOOL_EXPRESSION ) { CODE_BLOCK_NEXT } else { CODE_BLOCK_NEXT }
IF_STATEMENT -> if ( BOOL_EXPRESSION ) | identifier | { CODE_BLOCK_NEXT } else { CODE_BLOCK_NEXT }

WHILE_STATEMENT -> while ( BOOL_EXPRESSION ) { CODE_BLOCK_NEXT }
WHILE_STATEMENT -> while ( BOOL_EXPRESSION ) | identifier | { CODE_BLOCK_NEXT }

VOID_FUNCTION_CALL -> identifier ( ARGUMENTS ) ;
#                            |- tento identifier náleží {funkce}
VOID_FUNCTION_CALL -> ifj . identifier ( ARGUMENTS ) ;
#                                |- tento identifier náleží {vestavěné funkce}

RETURN -> return ;
RETURN -> return EXPRESSION ;